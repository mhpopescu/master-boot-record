	Pentru ca problema contine destul de multe linii de cod, pentru a fi mai usor de urmarit am inclus fiecare task in cate un header, unele din ele avand si functii suplimentare.

1)	Pentru primul task apelam functia TASK1, care initial valideaza adresele partitiilor. Prin variabila "e" validam succesul sau esecul incheierii unei operatii sau functii (am folosit-o si in celelalte task-uri).
	Initial verificam pentru prima partitie, care trebuie sa fie imediat dupa MBR. Daca mai exista partiti, de aici verificam cate directoare si fisiere are, deoarece dupa aceasta trebuie sa fie inceputul urmatoarei partitii. Facem acest lucru cat timp mai avem adrese de validat. Dupa verificam daca sunt valide sau nu (daca una dintre ele nu este valida se schimba valoarea variabilei "e") si afisam mesajul.
	In caz de succes vrem sa afisam acei bytes folositi si pe cei alocati. Functia T1_AFISARE face acest lucru. Parcurge fiecare partitie si citeste fiecare director si fisier in parte pentru a vedea cat spatiu este folosit.

2)	Pentru task-ul 2, deoarece a fost mai rapid de implementat am facut o functie pentru toate operatiile pe fisiere, la fel si pentru directoare. Pentru a sti care operatie urmeaza a fi executata, aceasta informatie este transmisa prin parametrul "x" functiei FILE_OP. Parcurgerea este aceeasi, doar ca acum se mai pune problema daca fisierul face parte dintr-un director sau nu, de aceea, functia este doar pentru a cauta unde se afla. Daca nu se gaseste locul unde trebuie facuta o operatie asupra fisierului se afiseaza INVALID, altfel se apeleaza functia FILE_OP_FUNCTIONS, care face operatiile propriu-zise. Daca trebuie creat, cauta loc si il creeaza; daca trebuie redenumit, este redenumit; daca trebuie sters il sterge. 
	Pentru directoare este cam acelasi lucru, doar ca sunt mai usor de gasit.
	Functia PRINT cauta directorul cel bun, la fel ca inainte si afiseaza ce e in el. Daca directorul nu e bun, apare mesajul INVALID.
	O mica optimizare pentru acest task este ca inainte sa fie apelate aceste functii incurcate se verifica daca este nevoie sa fie apelate. Mai exact, nicio operatie nu este valida daca parametrul path (citit din fisierul cu operatii) da numele unei partitii, caz prea des intalnit in exemple, care ar consuma din mult-pretiosul timp de executie. In acest caz afiseaza direct INVALID - mesaj devenit deja enervant.
	/* # // "comentariu" Desi task-ul este interesant si a fost nevoie de mare atentie in timpul scrierii problemei si depanarii eventualelor bug-uri, probabil tot s-a strecurat unul, pentru ca un test de pe vmchecker s-a autoproclamat "failed". Dupa mult efort in cautarea acestuia si cautarea mea s-a declarat INVALIDA. Probabil ar fi fost mai bine daca testele locale ar fi fost putin mai minutioase, pentru ca se pare ca incercarile mele nu au fost destul de complexe. */

3)	Functia pentru task-ul 3 cauta partitia si o sterge sau o formateaza, iar pentru a o creare se chinuie functia CREATE_PARTITION. Cat timp nu s-a depasit numarul de partitii se incearca gasirea unui loc liber pentru acea partitia care vrea sa devina si ea existenta. Deoarece atunci cand este stearsa una indexul ei devine 0, pentru a vedea unde se afla acel spatiu liber trebuie sa ne legam de partitia anterioara. Vedem unde se termina aceasta dupa numarul de directoare si fisiere, iar acolo incepe urmatoarea. Daca are loc, o noua partitie este creata si functia isi transmite succesul prin afisarea locului unde a fost salvata.

4)	Daca bug-ul de la task-ul 2 ar fi fost mai cumsecade, acum as fi explicat si bonusul, dar se pare ca Mbrel nu a vrut sa se intample acest lucru.
